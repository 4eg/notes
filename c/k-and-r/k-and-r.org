~#+TITLE: The C Programming Language - Notes

The C Programming Language
Second edition
1988
Brian W. Kernighan
Dennis M. Ritchie


* Preface

- *1978*: release of the *first edition* of /The C Programming Language/
  - The *only definition* for the C language at the time
  - Growing popularity + Changes + Creation of compilers by groups not involved in its design = Need for a more precise and contemporary definition

- *1983*: the ANSI established a committee whose goal was to create "an an unambiguous and machine-independent definition of the language C"
  - Based on the original reference manual
  - *Minor changes only* to ensure *compatibility* with existing programs \rightarrow Compilers would produce warnings of new behavior if not valid
  - \rightarrow The resulting definition, the *ANSI standard* or "*ANSI C*", was completed late in 1988

- *1988*: release of the *second edition* of /The C Programming Language/
  - Describes C as defined by the *ANSI standard*
  - Programs are written *exclusively* in the new form (no changes for the most part) + Improved examples with better exposition of features
  - Modern compilers *already complies* with the ANSI standard at the time
  - Brevity: "*C is not a big language, and it is not well served by a big book*"
  - Meant for *easy comprehension by programmers*, but *not as a definition for compiler writers* \rightarrow That role belongs to the standard itself
  - (Growth of the computing power: of PCs is the same of the rival mainframes of a decade ago)
  - (The authors were provided with an ANSI C compiler and used Bjarne Stroustrup's C++ translator)

- \rightarrow C "*wears well as one's experience with it grows*" is still true after a decade



* Preface to the First Edition

- C is a *general-purpose* programming language
  - Features: *economy of expression*, *modern control flow and data structures*, and a *rich set of operators*
  - Not a "very high level language", nor a "big" one, but versatile (i.e., not specialized to any particular area of application)
  - A "*system programming language*" as well: useful for writing compilers and operating system \rightarrow "*C is a portable assembly language*"
  - Absence of restrictions + Generality = More convenient and effective than supposedly more powerful languages

- C was originally designed for and implemented on the UNIX OS
  - The *OS*, the *C compiler*, and all *UNIX applications programs* are written in C \rightarrow *Thus, UNIX became the first portable operating system*
  - Portable: C is *not tied to any particular hardware or system* (the targeted architecture requires an implementation of the compiler, though)
  - (Created on the DEC PDP-11 by Dennis Ritchie)

- This book is based on *revising examples* rather than on *mere statements of rules*
  - Most of the examples are *concrete programs* rather than *isolated fragments of code* \rightarrow Illustrate useful algorithms and principle of good style and sound design
  - *Content*: Tutorial introduction + Separate chapters for each major feature + Reference manual
  - Assumes that the reader is familiar with basic programming concepts
  - (Each example has been tested directly from text, which is in a machine-readable form)

- \rightarrow "The *only way* to learn a new programming language is by *writing programs in it*."



* Introduction

- C is a relatively "*low level*" language \rightarrow Deals with the same sort of *objects that most computers do* (i.e., characters, numbers and addresses)
  - They may be *combined* and *moved about* with the arithmetic and logical operators implemented by real machines

- _C does feature_:

  - *Fundamental types* (i.e., characters, integers and floating-point numbers of several sizes) + a hierarchy of *derived data types* (created with pointers, arrays and unions)
  - *Expressions* are formed from *operators and operands*; any expression can be *a statement* (e.g., an assignment, a function call)
  - *Pointers* provide for machine-independent address arithmetic

  - *Control-flow constructions*:
    - Statement grouping
    - Decision making (~if-else~)
    - Selecting one of a set of possible cases (~switch~)
    - Looping with the termination test at the top (~while~, ~for~) or at the bottom (~do~)
    - Early loop exit (~break~)

  - *Functions* may return values of basic types, structures, unions, or pointers
    - Any function may be called *recursively*
    - *Local variables* are typically "automatic", or created anew with each invocation
    - Functions may not be *nested*, but variables may be declared in a block-structured fashion
    - They may exist in a *separate* source files that are compiled separately

  - *Variables* may be:
    - *Internal* to a function
    - *External* but known only within a single source file
    - *Visible to the entire program*

  - A *preprocessing step* performs:
    - *Macro substitution* on program text
    - *Inclusion* of other source files
    - *Conditional compilation*

  - *Straightforward* and *single-thread* control flow: tests, loops, grouping, and subprograms
    - *But no*: multiprogramming, parallel operations, synchronization, or coroutines

- _C does not feature_:

  - *Operations* to deal directly with *composite objects* such as character string, sets, lists, or array \rightarrow Although structures may be *copied as a unit*
  - *Heap* or *garbage collection*: no *storage allocation facility* other than *static definition* and the *stack discipline* provided by the local variables of functions
  - *Input/output facilities* (i.e., no READ or WRITE statements) nor built-in *file access methods*

- All of these higher-level mechanisms must be provided by *explicitly-called functions*
  - Although the absence of some of these features may seem like a *grave deficiency*, keeping the language down to modest size *has real benefits*
    - It can be described in a *small space*, and thus *learned quickly* \rightarrow A programmer can reasonably expect to *know*, *understand*, and *regularly use* the *entire language*

- Many of the important ideas of C stem from the *language BCPL*
  - The influence of BCPL on C proceeded indirectly through the language B
  - In contrast to C, B and BCPL are *typeless* languages
  - (1970: creation of the language B by Ken Thompson on the DEC PDP-7)

- _Contributions brought by the standard to the language_:

  - _Language changes_:
    - Most important one: *new syntax for declaring and defining functions*
      - Permits *cross-checking of definition with use*
      - A function declaration can now include a *description of the arguments* of the function; the definition syntax changes to match
      - \rightarrow Much easier for compiler to detect errors caused by *mismatched arguments*
    - Other ones:
      - Formalization of *structure assignment* and *enumerations* \rightarrow They were hinted but not described in the original definition
      - *Floating-point computations* may now be done in *single precision*
      - *Properties of arithmetic* are clarified \rightarrow Especially for unsigned types
      - The *preprocessor* is more elaborate
      - *Type-checking* has been strengthened (e.g., interchange of pointers and integers are now forbidden)
	- *Proper declarations* and *explicit conversions* are now required by the standard (but was already enforced in good compilers)
	- New function declarations are a step in this direction as well

  - _Definition of a library to accompany C_ \rightarrow Provides *a common interface to the OS*
    - *A collection of standard headers* provides uniform access to *declarations of function* and *data types*
    - *Assurance of compatible behavior* when a program using it is executed on different host systems
    - Closely modeled on the *standard I/O library* of the UNIX system (described in the first edition) \rightarrow Programmers will not see much change with the new library
    - Specifies *functions* for:
      - Accessing the OS (e.g., read and write files)
      - Formatted input and output
      - Memory allocation
      - String manipulation
      - ...
    - Functions are only called *explicitly* \rightarrow The library can be avoided if not used
    - Most of these functions are *written in C* \rightarrow They are *portable* (except for the OS details they might conceal)

- The *run-time library* required to implement self-contained program is *tiny* \rightarrow Due to *direct support of data types* and *control structures provided*

- *Portability*: C is independent of any particular *machine architecture* despite it matches the capabilities of many computers
  - The standard states explicitly *machine-dependent aspects* of the language \rightarrow Description of *portability issues* and *a set of constant that characterizes the host machine*

- C is not a *strongly-typed* language
  - Compilers will warn of most *type errors*, and there is *no automatic conversion* of incompatible data types
  - C retains the basic philosophy that "*programmers know what they are doing; it only requires that they state their intentions explicitly*"

- *Blemishes*:
  - Some of the operators have the *wrong precedence*
  - Some parts of the syntax *could be better* ([[https://stackoverflow.com/a/46759840][proof]])

- \rightarrow Nonetheless, C has proven to be an extremely *effective* and *expressive* language for a wide variety of programming applications



* Chapter 1: A Tutorial Introduction

- Shows the *essential elements* of the language without getting bogged down in details, rules and exceptions
- Neither *complete or precise* \rightarrow Features to write bigger programs are put aside (e.g, pointers, structures, set of operators, several control flow statements, standard library)
- *Focus on the basics*: variables and constants, arithmetic, control flow, functions, and the rudiments of input and output \rightarrow Write useful programs quickly
- Can be used as a *framework* for programmers of any level

- _Drawbacks of this approach_:
  - *No complete story* on any particular feature
  - May be *misleading*
  - Not using the *full power of C* \rightarrow Programs are not as *elegant* and *concise* as they might be
  - Later chapters will necessarily repeat some of the contents of this one


** 1.1 Getting Started

- _Creating a C program on the UNIX OS_:
  - The *text of a program* must be saved in a *file* whose name ends in ".c" (e.g., hello.c)
  - *Compile* this file with the command ~$ cc hello.c~ \rightarrow ~$ gcc hello.c~ on a GNU/Linux system
  - Compilation proceeds silently and makes an *executable file* named "*a.out*"
  - *Run* it by typing its name: ~$ a.out~ \rightarrow ~$ ./a.out~ on a GNU/Linux system

#+BEGIN_SRC C
  #include <stdio.h>

  main()
  {
          printf("hello, world\n");
  }
#+END_SRC

- _Explanations_:
  - A C program, whatever its size, consists of /functions/ and /variables/
    - *Functions* contain /statements/ that specify the computing operations to be done
      - The statements of a function are enclosed in braces ~{}~
    - *Variables* store values used during the computation

  - When defined, functions and variables can be given *any name* (except reserved keywords)
    - *Exception*: the program begins executing at the beginning of a function named ~main~ \rightarrow Every program must have a ~main~ function somewhere
      - ~main~ will usually *call other functions* that you either wrote or present in the standard library

  - ~#include <stdio.h>~ tell the *preprocessor* to include information about the *standard input/output library*

  - A function is called by *naming it*, followed by *a parenthesized list of arguments*
    - One method of *communicating data between functions* is for the *calling function* to provide *a list of values*, called /arguments/, to the *function it calls*
    - The argument list is delimited by a *pair of parentheses* after the function name \rightarrow Even if a function expects no arguments, an empty list ~()~ must be specified
    - (C functions are like the subroutines and functions of Fortran or the procedures and functions of Pascal)

  - A sequence of characters delimited by double quotes "" is called a /character string/ (or /string constant/)
    - The sequence ~\n~ is C notation for the /newline character/
      - ~\n~ is called an /escape sequence/ \rightarrow Provides a *general and extensible mechanism* for representing *hard-to-type or invisible characters*
	- ~\n~ represents *a single character* (at least on UNIX)
	- An *error message* might be produced by the C compiler when trying to *substitute an escape sequence* by the character it produces (e.g., the statement below)
      - If omitted, no line advance will occur after the output is printed \rightarrow ~printf~ never supplies a newline automatically and might be called *several times* to build up an output line in stages

#+BEGIN_SRC C
  printf("hello, world
  ");
#+END_SRC

_Exercises_:
- [[file:exercises/1-1/hello.c][Exercise 1-1]]
- [[file:exercises/1-2/escape_sequences.c][Exercise 1-2]]


** 1.2 Variables and Arithmetic Expressions

- A /comment/ explains briefly *what the program does* \rightarrow Make it easier to understand
  - Any characters between ~*/~ and ~*/~ are *removed by the preprocessor* before compilation
  - Comments may appear *anywhere a blank or tab or newline can*

- A /statement/ is terminated by a semicolon ~;~ \rightarrow Permits to *distinguish statements from what are not them*

- A /declaration/ announces the *properties of variables*
  - *All variables must be declared before they are used in C* \rightarrow Usually at the *beginning of the function* before any executable statement
  - declaration = type name + a list of variables \rightarrow E.g., ~int fahr, celsius;~
  - The size of the objects of these types are *machine-dependent* (e.g., 32-bit ~int~ VS 16-bit ~int~)
  - (Other data structures utilizes these basic types to create bigger data types)

- _Basic data types_ (non-exhaustive):

| Type     | Description                                                                            |
|----------+----------------------------------------------------------------------------------------|
| ~int~    | integer                                                                                |
| ~float~  | floating point number (typically a 32-bit quantity, with at least 6 significant digits) |
| ~char~   | character (a single byte quantity)                                                     |
| ~short~  | short integer                                                                          |
| ~long~   | long integer                                                                           |
| ~double~ | double-precision floating point                                                        |

- An /assignment statement/ assigns a value to a variable \rightarrow E.g., ~lower = 0;~
  - (This is where the computation starts)

- A *loop* repeats one or more statements while *a condition is true*
  - Composed of: *a condition* enclosed in parentheses ~()~ + *a body* enclosed in braces ~{}~ (optional if containing a single statement)
  - The condition is *re-evaluated at each iteration*
  - When the condition becomes false, the *execution continues* at the next statement

- *Proper indentation and spacing* are not required by the compiler but are *critical to make the program easier to read*
  - The /indentation/ emphasizes the *logical structure of a program*
    - E.g, statements inside the loop are indented by one tab stop
  - *One statement per line* is recommended
  - *Blanks placed around operators* clarify grouping
  - The *position of braces* is less important and depends on the style picked
    - \rightarrow *No matter what the style is, the important is to use it consistently*

- *Integer division truncates* in C (as in many other languages) \rightarrow *Any fractional part is discarded*
  - ~celsius = 5 * (fahr-32) / 9~ would *result in 0* if the division was the first operation \rightarrow *But the result is still truncated*
    - If an arithmetic operator has *integer operands*: *an integer operation* is performed
  - The ~float~ *type can be used instead*
    - If an arithmetic operand has *one integer* and *one floating-point operand*: *integer operand is converted to floating-point operand* and *floating-point operation* is performed
      - Prefer to write floating-point constants *ending with* ~.0~ (or ~.~) instead of integer constants when *dealing with other floating-point operands* \rightarrow Emphasizes their *floating-point nature* + *avoid conversion*

- ~printf~ is *a general-purpose output formatting function*
  - *Not part of the C language* (recall that no I/O defined in C itself) but part of the *standard library*
  - The first argument is the *string of characters to be printed*
  - The other arguments are the *values that substitutes each format specifier*
    - ~%d~ and ~%f~ can be augmented with a *minimum width* (right-justifies) \rightarrow E.g., ~%3d~, ~%2f%~
    - ~%f~ can be be augmented with a *maximum number of digits after the decimal point* \rightarrow E.g., ~%.2f%, ~%3.0f%~
  - (Format specifiers and arguments must *match up properly* by *number* and *type* under penalty of wrong output)

- _Format specifiers_ (non-exhaustive):

| Format specifier | Specified argument |
|------------------+--------------------|
| ~%d~             | integer            |
| ~%f~             | floating-point     |
| ~%o~             | octal              |
| ~%x~             | hexadecimal        |
| ~%c~             | character          |
| ~%s~             | character string   |

- ~%%~ must be used to output the ~%~ itself

_Exercises_:
- [[file:exercises/1-3/f_to_c.c][Exercise 1-3]]
- [[file:exercises/1-4/c_to_f.c][Exercise 1-4]]


** 1.3 The For Statement

- *General rule*: In any context where it is permissible to use the value of a variable of some type. you can use *a more complicated expression of that type*

- There are *plenty of different ways* to write a program for *a particular task*

- A ~for~ loop can be used instead of the ~while~ in the previous program
  - Generalization of a ~while~
  - Appropriate for loops in which the *initialization* and *increment* are *single statements* and *logically related*
  - Keeps the loop control statements *together in one place*

- _For loop syntax_:

#+BEGIN_SRC C
  for (/* initialization */; /* condition */; /* increment */) {
          /* body */
  }
#+END_SRC

- Parts:
  - *Initialization*: assign a value to a variable when the loop is entered \rightarrow Not a variable declaration
  - *Condition*: specifies when the loop ends + re-evaluated at each iteration
  - *Increment*: update the value of a variable at each iteration
- Most of the time, these parts are related to *a same variable* \rightarrow But not mandatory (e.g., ~for (i = 0; flag == 0; ++i)~)
  - They can be *any expressions*
  - Any part can even be left *empty* between ~;~ \rightarrow Infinite loop if none

- *Recommendation for loops*: use a ~for~ *when the number of iterations is known beforehand* and a ~while~ *when not*

_Exercises_:
- [[file:exercises/1-5/f_to_c.c][Exercise 1-5]]


** 1.4 Symbolic Constants

- *Bad practice*: bury "magic numbers" in a program (e.g., 300, 20) \rightarrow Convey *little information* to the reader + Must change all occurrences when *updating values*
  - *Solution*: give them meaningful name via /symbolic constants/

- _Symbolic constant syntax_:

#+BEGIN_SRC C
  #define NAME replacement_text
#+END_SRC

- *A search and replace operation*: Any occurrence of ~NAME~ will be *replaced* by the corresponding ~replacement_text~ in the program text \rightarrow Done during the *preprocessing step*
  - ~NAME~ will not be replaced when *in quotes* or *part of another name*
  - ~NAME~ must respect the same naming rules as *a variable name* \rightarrow Conventionally written in *upper case* to be readily distinguished
  - ~replacement_text~ can be *any text* that will *make sense in the context where it will be replaced with* (e.g., integers, floating-point number, type, type with variable name, function name, text in quotes)

- Symbolic constants must *not appear in declarations* since they are not variables \rightarrow Generally under ~#include~ directives
- (Note that there is no ~;~)


** 1.5 Character Input and Output

- This part focuses on *a family of related programs* for *processing character data*
  - Many UNIX programs are just *expanded versions* of the prototypes discussed

- The *model of input and output* supported by the *standard library* is very simple: text input or output is dealt with as *stream of characters*
  - A /text stream/ is a *sequence of characters* divided into *lines*; each line consists of *0 or more characters* followed by *a newline character*
  - The *standard library* is responsible for making each input or output stream *conform to this model* \rightarrow The programmer does not need to worry about *how lines are represented outside the program*

- Several functions are provided for *reading or writing one character at a time*
  - *Simplest ones*:
    - ~getchar~: reads the /next input character/ from a text stream and returns that as its value (e.g., ~c = getchar()~)
    - ~putchar~: prints the character passed as argument (e.g. ~putchar('A')~ \rightarrow ~A~, ~putchar(97)~ \rightarrow ~a~)


*** 1.5.1 File Copying

- ~getchar~ and ~putchar~ are *sufficient to write useful programs* without knowing anything more about *input and output*

#+BEGIN_SRC C
  #include <stdio.h>

  /* copy input to output */
  main()
  {
          int c;

          while ((c = getchar()) != EOF)
                  putchar(c);
  }
#+END_SRC

- A character is *stored internally as a bit pattern* (like everything else on a computer)
- The ~c~ variable is used to *store and reuse the read character*
  - \rightarrow If you do not need to work on the read character (e.g., with a counter), you *do not need a variable*
- Although the data type ~char~ is specifically meant for storing characters, ~int~ is used instead because it provides *a wider range of values* to hold characters not present in the ASCII table
  - (+ Apparently, there was a time where ~char~ could not hold ~EOF~ + any possible ~char~)

- ~EOF~ ("*End of file*") is a *symbolic constant* defined in ~<stdio.h>~ that can be used to *distinguish the end of input from valid data*
  - Has to be *distinct from any character that can be found in a file* to serve its purpose \rightarrow Often defined as -1
  - The ~EOF~ value is returned by ~getchar~ when there is *no more input*

- *Expressions* in C have *a value*
  - *Assignments* are expressions and their value is the *one of the left hand side* after the assignment
    - Thus, assignments can be part of *another expression* (e.g., ~(a = 8) + 8~) \rightarrow Easier to read once the *idiom is mastered*
      - ~()~ *are necessary* \rightarrow The /precedence/ of ~!=~ is *higher than that of* ~=~

_Exercises_:
- [[file:exercises/1-6/i2bool.c][Exercise 1-6]]
- [[file:exercises/1-7/eofval.c][Exercise 1-7]]


*** 1.5.2 Character Counting

#+BEGIN_SRC C
  #include <stdio.h>

  /* count characters in input */
  main()
  {
          long nc;                /* number of characters */

          nc = 0;
          while (getchar() != EOF)
                  ++nc;
          printf("%ld\n", nc);
  }
#+END_SRC

- The ~++~ operator /increments by 1/ the value of a variable \rightarrow Shorter than ~nc  = nc + 1~
  - Also available: the ~--~ operator (/decrements/)
  - They can be either *prefix operators* (e.g., ~++nc~) or *postfix* (e.g., *nc++*) \rightarrow Stick to the *prefix form* most of the time

- The ~long~ type (at least 32-bit) is used because the number of characters in a file can easily *overflow a ~16-bit int~ counter*
  - Although, the ~long~ and ~int~ types are the *same size on modern computers* most of the time
  - ~%ld~ is the *format specifier for* a ~long~ integer
  - An even *wider range of values* could have been provided *utilizing a ~double~ counter*

#+BEGIN_SRC C
  double nc;

  for (nc = 0; getchar() != EOF; ++nc)
          ;
  printf("%.0f\n", nc);
#+END_SRC

- If a *single operation* is executed while iterating through the file, one could prefer using *a ~for~ statement*
  - The grammatical rules of C *require that a ~for~ statement have a body* \rightarrow Represented by the ~;~, called a /null statement/ (newline for visibility, not mandatory + Empty ~{}~ could have been used as well)
  - The *increment part* of the for loop could have been omitted and *placed in the loop body* \rightarrow Clearer to use a ~while~ in that case (+ if there is more than one statement while iterating through)

- Since a ~double~ is a floating-point value, ~%.0~ must be used to *truncate its fractional part*

- *Important*: For both ~while~ and ~for~ versions, the *boundary case* "zero length input" prints the right answer
  - \rightarrow The *loop condition is evaluated at the top of the loop* for both, before proceeding with the body
  - ~getchar~ returns ~EOF~ at the very first test \rightarrow The condition is *false* \rightarrow The body of the loop is *never entered*

- \rightarrow *Programs should act intelligently when tested with boundary conditions*


*** 1.5.3 Line Counting

#+BEGIN_SRC C
  #include <stdio.h>

  /* count lines in input */
  main()
  {
          int c, nl;

          nl = 0;
          while ((c = getchar()) != EOF)
                  if (c == '\n')
                          ++nl;
          printf("%d\n", nl);
  }
#+END_SRC

- Since the standard library ensures that text streams follows the same model, *counting lines is just counting newlines*

- ~==~ is the C notation for "*is equal to*" \rightarrow Different from the *assignment operator ~=~* \rightarrow *Warning: both operators produces legal expressions*

- A /character constant/ is *a character written between single quotes* that represents *an integer value equal to the numerical value of the character in the machine's character set* (e.g., ~'A' == 65~ is true)
  - An escape sequence is interpreted as *a single character* \rightarrow Thus, they are legal as *character constants* (e.g., ~'\n' == 10~ is true)
    - *Different from the string constant ~"\n"~* (which contains one character: ~'\n'~)

#+BEGIN_SRC C
  char c;

  for (c = 'A'; c <= 'Z'; ++c) {
          /* iterates over characters A to Z */
  }
#+END_SRC

- \righarrow *Always prefer to work with character constants over their numerical value*
  - + Independence of *a particular character set* (even if ASCII is almost always used)

_Exercises_:
- [[file:exercises/1-8/spcc.c][Exercise 1-8]]
- [[file:exercises/1-9/sb.c][Exercise 1-9]]
- [[file:exercises/1-10/spcr.c][Exercise 1-10]]


*** 1.5.4 Word Counting

#+BEGIN_SRC C
  #include <stdio.h>

  #define IN      1               /* inside a word */
  #define OUT     0               /* outside a word */

  /* count lines, words, and characters in input */
  main()
  {
          int c, nl, nw, nc, state;

          state = OUT;
          nl = nw = nc = 0;
          while ((c = getchar()) != EOF) {
                  ++nc;
                  if (c == '\n')
                          ++nl;
                  if (c == ' ' || c == '\n' || c == '\t')
                          state = OUT;
                  else if (state == OUT) {
                          state = IN;
                          ++nw;
                  }
          }
          printf("%d %d %d\n", nl, nw, nc);
  }
#+END_SRC

- \rightarrow *Bare-bones version* of the UNIX program ~wc~
- *Loose definition of a word*: any sequence of characters that does not contain a blank, tab, or newline
- A word is counted every time the *first character of word is encountered*

- ~state~ stores whether the program is currently *in a word or not*
  - Notice how ~IN~ and ~OUT~ make the program *easier to read* (instead of /literal values/ / "magic numbers") \rightarrow Little difference in this program, but worth it in larger programs for *clarity* and *maintainability* (+ no performance cost at compilation)

- ~a = b = c = 0;~ precedence: ~(a = (b = (c = 0)));~

- ~||~: *logical or* (between expressions)
- ~&&~: *logical and* (between expressions) \rightarrow *Higher precedence than* ~||~
  - Expressions connected by those operators are *expressions as well* (just larger)
    - Evaluated from *left to right* \rightarrow *Guaranteed that evaluation will stop as soon as the truth or falsehood is known*
      - E.g., in this program, if ~c~ is equal to ~' '~, the following tests with '\n' and '\t' respectively *are not evaluated*

if (/expression/)
	/statement/_1
else
	/statement/_2

- ~else~ specifies *an alternative action* if the condition part of an ~if~ statement is *false*
  - If the /expression/ is true, /statement/_1 is executed; if not, /statement/_2 is executed
  - An ~else~ /statement/_2 can be any statement, *even an* ~if~ *statement to test another condition* \rightarrow *WARNING*: ~else if~ *is not a statement by itself*
    - *E.g., in this program, the statement after the* ~else~ *is an* ~if~ *that controls two statements in braces*

#+BEGIN_SRC C
  /* the following statements */
  if (0)
          putchar('A');
  else if (0)
          putchar('B');
  else
          putchar('C');

  /* are the same as: */
  if (0) {
          putchar('A');
  } else if (0) {
          putchar('B');
  } else {
          putchar('C');
  }

  /* which are the same as: */
  if (0) {
          putchar('A');
  } else { if (0) {
          putchar('B');
  } else {
          putchar('C');
  }}

  /* which are at last the same as: */
  if (0) {
          putchar('A');
  } else {
          if (0) {
                  putchar('B');
          } else {
                  putchar('C');
          }
  }
#+END_SRC

- \rightarrow *Do not let the optional braces fool you*
  - An ~if-else~ is *a single statement* \rightarrow If an ~if-else~ is the *only statement* contained in an ~else~, the *braces of the latter can be omitted*

#+BEGIN_SRC C
  if (8 != 7) if (9 != 5) {
                  /* possible as well */
  }
#+END_SRC

_Exercises_:
- [[file:exercises/1-11/wc.c][Exercise 1-11]]
- [[file:exercises/1-12/wpl.c][Exercise 1-12]]


*** 1.6 Arrays

#+BEGIN_SRC C
  #include <stdio.h>

  /* count digits, white space, others */
  main()
  {
          int c, i, nwhite, nother;
          int ndigit[10];

          nwhite = nother = 0;
          for (i = 0; i < 10; ++i)
                  ndigit[i] = 0;

          while ((c = getchar()) != EOF)
                  if (c >= '0' && c <= '9')
                          ++nidigits[c-'0'];
                  else if (c == ' ' || c == '\n' || c == '\t')
                          ++nwhite;
                  else
                          ++nother;

          printf("digits = ");
          for (i = 0; i < 10; ++i)
                  printf(" %d", ndigit[i]);
          printf(", white space = %d, other = %d\n", nwhite, nother);
  }
#+END_SRC

- More convenient to use an /array/ rather than multiple *individual variables* \rightarrow Useful to store *related variable* into a single one
- ~int ndigit[10];~ declares ~ndigit to be *an array of 10 integers*
- *Array subscripts always start at zero in C*
  - The /elements/ of ~ndigit~ can be accessed from 0 to 9
- A subscript can be *any integer expression* (e.g., ~8~, ~i~, ~++i~)
- Since we expect the counters contained in ~ndigit~ to be 0, we must *initialize each element to 0* \rightarrow *Might contain garbage by default*

- This program relies on the properties of the *character representation of the digits*
  - *The numerical value of a digit is not the digit itself* in the ASCII table (e.g, ~'8' == 8~ is false)
  - Recall that you do not need to know/use the *numerical value of a particular character* of your character set (e.g., ~c >= '0' && c <= '9'~)
  - Since ~chars~ are just small integers, ~char~ *variables and constants are identical to* ~ints~ *in arithmetic expressions*
    - E.g., ~c - '0'~ is a integer expression with a value between 0 and 9 corresponding to the character '0' to '9' stored in ~c~ \rightarrow Can be used as a valid subscript for ~ndigit~
  - (~c - '0'~ works only if '0' to '9' have *consecutive increasing numerical values* \rightarrow True for all (sane) character sets)

#+BEGIN_VERSE
~if~ (/condition_1/)
	/statement_1/
~else if~ (/condition_2/)
	/statement_2/
...
	...
~else~
	/statement_n/
#+END_VERSE

- Frequent pattern in programs as a way to express *a multi-way decision*
- The /conditions/ are evaluated *in order from the top until some* /condition/ *is satisfied* \rightarrow Execution of the *corresponding* /statement/ \rightarrow *End of the entire construction*
  - ~else~ is executed if *none of the conditions is satisfied*
- There can be *any number of* ~else if~ *groups* between the initial ~if~ and the final ~else~
- (Any /statement/ can be several statements enclosed in braces)

- ~switch~ statements provides another way to write *a multi-way branch* that is particularly suitable when the condition is whether some integer or character expression *matches one of a set of constants*

_Exercises_:
- [[file:exercises/1-13/histlen.c][Exercise 1-13]]
- [[file:exercises/1-14/histc.c][Exercise 1-14]]


** 1.7 Functions

- A function provides a convenient way to *encapsulate some computation* which can then be used *without worrying about its implementation*
- "With properly designed functions, it is possible to ignore /how/ a job is done; knowing /what/ is done is sufficient."
- Often, a short function is *defined and called only once*, just because it *clarifies some piece of code*

#+BEGIN_SRC C
  #include <stdio.h>

  int power(int m, int n);

  /* test power function */
  main()
  {
          int i;

          for (i = 0; i < 10; ++i)
                  printf("%d %d %d \n", i, power(2,i), power(-3,i));
          return 0;
  }

  /* power:  raise base to n-th power; n >= 0 */
  int power(int base, int n)
  {
          int i, p;

          p = 1;
          for (i = 1; i <= n; ++i)
                  p = p * base;
          return p;
  }
#+END_SRC

- (Not a practical exponentiation routine: handles only positive powers of small integers)
- (The standard library contains a function ~pow(x,y)~ that computes x^y)

_Form of a function definition:_
#+BEGIN_VERSE
/return-type/ /function-name/(/parameter declarations, if any/)
{
	/declarations/
	/statements/
}
#+END_VERSE

- Functions definitions can appear:
  - In *any order*
  - In *a single source file* or *several* \rightarrow But *cannot be split* across them
    - May require to provide *additional instructions* in order to compile the program if the source appears in several files \rightarrow This is an OS matter, *not a language attribute*

- ~printf("%d %d %d \n", i, power(2,i), power(-3,i));~
  - Each call passes *2 arguments* to power, which each time *returns an integer* to be formatted and printed
    - Recall that ~power(2,i)~ is an integer just as ~2~ and ~i~ are

- ~int power(int base, int n)~
  - Declares the *parameter types and names* + the *type of the result* that the function returns
  - *The name used by* ~power *for its parameters are local to this function* + *the variables of* /declarations/ (i.e., ~i~ and ~p~)
    - \rightarrow The ~i~ in ~power~ is *unrelated* to the ~i~ in ~main~

- "We will generally use /parameter/ for a variable named in the parentesized list in a function definition, and /argument/ for the value used in a call of the function."
  - "The terms /formal argument/ and /actual argument/ are sometimes used for the same distinction."

- The value that ~power~ computes is *returned to* ~main~ by the ~return~ statement
  - *Any expression* may follow ~return~
  - A function *does not need to return a value*
  - ~return~ followed with no expression has *the same effect* as falling off the end of a function: *control is returned to caller* (but no useful value)
  - The returned value can be *ignored* by the calling function
  - Since ~main~ is a function like any other, *it may return a value to its caller* (i.e., the *environment* in which the program was executed)
    - *Programs should return status to their environment*
    - Typically, zero implies *normal termination* and non-zero values implies *unusual or erroneous termination conditions*
    - ~return 0;~ is *added automatically* by modern compilers when omitted

- ~int power(int m, int n);~
- This /function prototype/ is a *declaration* that says that ~power~ is a function that expects two ~int~ arguments and returns an ~int~
  - Has to agree with the *definition and uses of* ~power~ \rightarrow It is an error otherwise
    - *Exception*: parameter names; which are optional \rightarrow Prototype could have been written: ~int power(int, int)~
      - Often, different names will be chosen to server as *good documentation* for the purpose of a parameter

_Function declaration in the original defintion of C:_
#+BEGIN_SRC C
  /* power:  raise base to n-th power; n >= 0 */
  /*         (old-style version */
  power(base, n)
  int base, n;
  {
          int i, p;

          p = 1;
          for (i = 1; i <= n; ++i)
                  p = p * base;
          return p;
  }
#+END_SRC

- Biggest change between ANSI C ans earlier versions: *function declarations and definitions*
- *Parameters*: names between ~()~ + types before the ~{~ (undeclared parameters considered as ~int~)
- Declaration of ~power~ at the beginning of the program:

#+BEGIN_SRC C
  int power();
#+END_SRC

- *No parameter list* was permitted \rightarrow Compiler could not *readily check* that the function was being called correctly
  - Note: since the *default return type was* ~int~, this entire declaration *could have been omitted*
- \rightarrow With the new syntax, much easier for a compiler to *detect errors* in the *number of arguments* or *their types*
- (The old style still works in ANSI C (at least for a transition period) but is strongly deprecated)

_Exercises_:
- [[file:exercises/1-15/f2c.c][Exercise 1-15]]


** 1.8 Arguments - Call by Value

- All function arguments are passed "*by value*" in C
  - \rightarrow The called function is given the values of its arguments in *temporary variables* rather than the originals
  - *Cannot directly alter a variable* in the calling function; it can only *alter its private, temporary copy*
  - Lead to more *compact* programs with *fewer extraneous variables* \rightarrow Parameters are like *initialized local variables*
  - Leads to some different properties than are seen with "*call by reference*" (like in Fortran, or with ~var~ parameters in Pascal)

_Function altering a parameter:_
#+BEGIN_SRC C
  /* power:  raise base to n-th power; n>=0; version 2 */
  int power(int base, int n)
  {
          int p;

          for (p = 1; n > 0; --n)
                  p = p * base;
          return p;
  }
#+END_SRC

- The variable ~i~ is no longer needed
- Whatever is done to the parameter will *not alter the original argument*

- A function can modify a variable anyway by *providing the* /address/ *of the variable to be set* (technically a /pointer/ to the variable)
  - The parameter type must be *a pointer* as well
  - This address would *be copied to the called function* like other arguments
  - When an *array* is passed as argument, *the address of the first element is actually passed* (this address is copied, not the elements)
    - Any element can be accessed/altered by *subscripting the parameter*


** 1.9 Character Arrays

- Most common type of array in C: *array of characters*

_Outline of a program that reads a set of of text lines and prints the longest:_
#+BEGIN_VERSE
~while (/there's another line/)
	if (/it's longer than the previous longest/)
		/save it/
		/save its length/
/print longest line/
#+END_VERSE

- \rightarrow The program *divides naturally into pieces*:
  - Get a new line
  - Test it
  - Save it
  - Control the process

#+BEGIN_SRC C
  #include <stdio.h>
  #define MAXLINE 1000            /* maximum input line size */

  int getline(char line[], int maxline);
  void copy(char to[], char from[]);

  /* print longest input line */
  main()
  {
          int len;                /* current line length */
          int max;                /* maximum length seen so far */
          char line[MAXLINE];     /* current input line */
          char longest[MAXLINE];  /* longest line save here */

          max = 0;
          while ((len = getline(line, MAXLINE)) > 0)
                  if (len > max) {
                          max = len;
                          copy(longest, line);
                  }

          if (max > 0)            /* there was a line */
                  printf("%s", longest);
          return 0;
  }

  /* getline: read a line into s, return length */
  int getline(char s[], int lim)
  {
          int c, i;

          for (i=0; i<lim-1 && (c=getchar())!=EOF && c!='\n'; ++i)
                  s[i] = c;
          if (c == '\n') {
                  s[i] = c;
                  ++i;
          }
          s[i] = '\0';
          return i;
  }

  /* copy: copy 'from' into 'to'; assume to is big enough */
  void copy(char to[], char from[])
  {
          int i;

          i = 0;
          while ((to[i] = from[i]) != '\0')
                  ++i;
  }
#+END_SRC

| h | e | l | l | o | \n | \0 |

 - Convention for strings of characters in C: stored as *an array of characters* containing the *characters of the string* and *terminated with a* ~'\0'~ to mark the end
  - ~'\0'~ is called the /null character/, whose value is zero
  - Implies that ~'\0'~ is not part of normal text
  - The ~%s~ format specification in ~printf~ expect a string *represented in this form*
  - ~copy~ relies on strings terminated by ~'\0'~ as well

- Providing the the size of an array in a declaration (e.g., ~char line[MAXLINE];~) is to *set aside storage*
  - The length of the array parameters of ~getline~ and ~copy~ are omitted *since the size of arguments is set in* ~main~

- The return type of ~getline~ is optional *since* ~int~ *is the default one*
- The return type of ~copy~ is ~void~ \rightarrow States explicitly that *no value is returned*

- ~getline~ *fetches the next line of input*
  - Made to be reused in *other contexts*
  - Stops fetching when:
    - The character read is either *a newline or* ~EOF~
    - The array ~s~ *size limit* has been reached
  - Returns the *length of line*
    - Returns 0 if ~EOF~ (+ never a valid line length), 1 if the line contains only a newline (i.e., is empty)
  - The ~lim~ parameter could have been substituted with the *symbolic constant* ~MAXLINE~
    - \rightarrow However, a program could need to call ~getline~ with different ~lim~ values each time
  - ~if (c == '\n')~ is entered if *it is the test that put an end to the previous* ~for~ *loop* \rightarrow Redundant; but is there another way?
  - (~getline~ is already function defined in the modern stardard library \rightarrow Rename it (e.g., ~readline~)

- ~copy~ has to copy array items one by one \rightarrow Arrays *cannot be copied like basic data types* (pointer is copied otherwise)

- ~main~ communicates with the other functions through *arguments and returned value*
- ~main~ and the function prototypes and definitions are *assumed to be contained in a one file*
- The name of the parameters in the function prototype are *more descriptive* to document them better

- _Sticky design problems_:
  - What should do ~main~ if ~MAXLINE~ is exceeded? \rightarrow ~getline~ *works safely*: stop fetching *when the array is full before a* ~'\n'~ / ~EOF~
    - ~main~ could check if a line is truncated by testing if the *returned length equals* ~MAXLINE~ and if the *last character is not* ~'\n'~ / ~EOF~
      - \rightarrow *Store multiple longest lines*?
    - ~copy~ *does not check for overflow errors*
      - \rightarrow No safety needed (not like ~getline~): the size of arguments *is already known / can be found out*

_Exercises_:
- [[file:exercises/1-16/ll.c][Exercise 1-16]]
- [[file:exercises/1-17/p80.c][Exercise 1-17]]
- [[file:exercises/1-18/rts.c][Exercise 1-18]]
- [[file:exercises/1-19/rev.c][Exercise 1-19]]
