#+TITLE: The C Programming Language - Notes

The C Programming Language
Second edition
1988
Brian W. Kernighan
Denis M. Ritchie


* Preface

- *1978*: release of the *first edition* of /The C Programming Language/
  - The *only definition* for the C language at the time
  - Growing popularity + Changes + Creation of compilers by groups not involved in its design = Need for a more precise and contemporary definition

- *1983*: the ANSI established a committee whose goal was to create "an an unambiguous and machine-independent definition of the language C"
  - Based on the original reference manual
  - *Minor changes only* to ensure *compatibility* with existing programs \rightarrow Compilers would produce warnings of new behavior if not valid
  - \rightarrow The resulting definition, the *ANSI standard* or "*ANSI C*", was completed late in 1988

- *1988*: release of the *second edition* of /The C Programming Language/
  - Describes C as defined by the *ANSI standard*
  - Programs are written *exclusively* in the new form (no changes for the most part) + Improved examples with better exposition of features
  - Modern compilers *already complies* with the ANSI standard at the time
  - Brevity: "*C is not a big language, and it is not well served by a big book*"
  - Meant for *easy comprehension by programmers*, but *not as a definition for compiler writers* \rightarrow That role belongs to the standard itself
  - (Growth of the computing power: of PCs is the same of the rival mainframes of a decade ago)
  - (The authors were provided with an ANSI C compiler and used Bjarne Stroustrup's C++ translator)

- \rightarrow C "*wears well as one's experience with it grows*" is still true after a decade



* Preface to the First Edition

- C is a *general-purpose* programming language
  - Features: *economy of expression*, *modern control flow and data structures*, and a *rich set of operators*
  - Not a "very high level language", nor a "big" one, and versatile (i.e., not specialized to any particular area of application)
  - A "*system programming language*" as well: useful for writing compilers and operating system \rightarrow "*C is a portable assembly language*"
  - Absence of restrictions + Generality = More convenient and effective than supposedly more powerful languages

- C was originally designed for and implemented on the UNIX OS
  - The *OS*, the *C compiler*, and all *UNIX applications programs* are written in C \rightarrow *Thus, UNIX became the first portable operating system*
  - Portable: C is *not tied to any particular hardware or system* (the targeted architecture requires an implementation of the compiler, though)
  - (Created on the DEC PDP-11 by Dennis Ritchie)

- This book is based on *revising examples* rather than on *mere statements of rules*
  - Most of the examples are *concrete programs* rather than *isolated fragments of code* \rightarrow Illustrate useful algorithms and principle of good style and sound design
  - *Content*: Tutorial introduction + Separate chapters for each major feature + Reference manual
  - Assumes that the reader is familiar with basic programming concepts
  - (Each example has been tested directly from text, which is in a machine-readable form)

- \rightarrow "The *only way* to learn a new programmming language is by *writting programs in it*."



* Introduction

- C is a relatively *low level* language \rightarrow Deals with the same sort of *objects that most computers do* (i.e., characters, numbers and addresses)
  - They may be *combined* and *moved about* with the arithmetic and logical operators implemented by real machines

- _C does feature_:

  - In addition to *fundamental types* (i.e., characters, integers and floating-point numbers of several sizes), there is a hierarchy of *derived data types* created with pointers, arrays and unions
  - *Expressions* are formed from operators and operands; any expression, including an assignment or a function call, can be a statement
  - *Pointers* provide for machine-independent address arithmetic

  - *Control-flow constructions*:
    - Statement grouping
    - Decision making (~if-else~)
    - Selecting one of a set of possible cases (~switch~)
    - Looping with the termination test at the top (~while~, ~for~) or at the bottom (~do~)
    - Early loop exit (~break~)

  - *Functions* may return values of basic types, structures, unions, or pointers
    - Any function may be called *recursively*
    - *Local variables* are typically "automatic", or created anew with each invocation
    - Functions may not be *nested*, but variables may be declared in a block-structured fashion
    - They may exist in a *separate* source files that are compiled separately

  - *Variables* may be:
    - *Internal* to a function
    - *External* but known only within a single source file
    - *Visible to the entire program*

  - A *preprocessing step* performs:
    - *Macro substitution* on program text
    - *Inclusion* of other source files
    - *Conditional compilation*

  - *Straightforward* and *single-thread* control flow: tests, loops, grouping, and subprograms, but not multiprogramming, parallel operations, synchronization, or coroutines

- _C does not feature_:

  - *Operations* to deal directly with *composite objects* such as character string, sets, lists, or array \rightarrow Although structures may be copied as a unit
  - *Heap* or *garbage collection*: no *storage allocation facility* other than *static definition* and the *stack discipline* provided by the local variables of functions
  - *Input/output facilities* (i.e., no READ or WRITE statements) nor built-in *file access methods*

- All of these higher-level mechanisms must be provided by *explicitly-called functions*
  - Although the absence of some of these features may seem like a *grave deficiency*, keeping the language down to *modest size has real benefits*
    - It can be described in a *small space*, and thus *learned quickly* \rightarrow A programmer can reasonably expect to *know*, *understand*, and *regularly use* the *entire language*

- Many of the important ideas of C stem from the *language BCPL*
  - The influence of BCPL on C proceeded indirectly through the language B
  - In contrast to C, B and BCPL are *typeless* languages
  - (1970: creation of the language B by Ken Thompson on the DEC PDP-7)

- _Contributions brought by the standard to the language_:

  - _Language changes_:
    - Most important one: *new syntax for declaring and defining functions*
      - Permits *cross-checking of definition with use*
      - A function declaration can now include a *description of the arguments* of the function; the definition syntax changes to match
      - \rightarrow Much easier for compiler to detect errors caused by mismatched arguments
    - Other ones:
      - Formalization of *structure assignment* and *enumerations* \rightarrow They were hinted bu not described in the original definition
      - *Floating-point computations* may now be done in *single precision*
      - *Properties of arithmetic* are clarified \rightarrow Especially for unsigned types
      - The *preprocessor* is more elaborate
      - *Type-checking* has been strengthened (e.g., interchange of pointers and integers are now forbidden)
	- *Proper declarations* and *explicit conversions* are now required by the standard (but was already enforced in good compilers)
	- New function declarations are a step in this direction as well

  - _Definition of a library to accompany C_ \rightarrow Provides a common interface to the OS
    - *A collection of standard headers* provides uniform access to *declarations of function* and *data types*
    - *Assurance of compatible behavior* when a program using it is executed on different host systems
    - Closely modeled on the *standard I/O library* of the UNIX system (described in the first edition) \rightarrow Programmers will not see much change with the new library
    - Specifies *functions* for:
      - Accessing the OS* (e.g., read and write files)
      - Formatted input and output
      - Memory allocation
      - String manipulation
      - ...
    - Functions are only called *explicitly* \rightarrow The library can be avoided if not used
    - Most of these functions are *written in C* \rightarrow Thus they are *portable* (except for the OS details they might conceal)

- The *run-time library* required to implement self-contained program is *tiny* \rightarrow Due to direct support of data types and control structures provided

- *Portability*: C is independent of any particular *machine architecture* despite it matches the capabilities of many computers
  - The standard states explicitly *machine-dependent aspects* of the language \rightarrow Description of *portability issues* and *a set of constant that characterizes the host machine*

- C is not a *strongly-typed* language
  - Compilers will warn of most *type errors*, and there is *no automatic conversion* of incompatible data types
  - C retains the basic philosophy that "*programmers know what they are doing; it only requires that they state their intentions explicitly*"

- *Blemishes*:
  - Some of the operators have the *wrong precedence*
  - Some parts of the syntax *could be better* ([[https://stackoverflow.com/a/46759840][proof]])

- \rightarrow Nonetheless, C has proven to be an extremely *effective* and *expressive* language for a wide variety of programming applications



* Chapter 1: A Tutorial Introduction

- Shows the *essential elements* of the language without getting bogged down in details, rules and exceptions
- Neither complete or precise \rightarrow Features to write bigger programs are put aside (e.g, pointers, structures, set of operators, several control flow statements, standard library)
- *Focus on the basics*: variables and constants, arithmetic, control flow, functions, and the rudiments of input and output \rightarrow Write useful programs ASAP
- Can be used as a *framework* for programmers of any level

- Drawbacks of this approach:
  - *No complete story* on any particular feature
  - May be *misleading*
  - Not using the *full power of C* \rightarrow Programs are not as *elegant* and concise as they might be
  - Later chapters will necessarily repeat some of the contents of this one


** 1-1 Getting Started

- _Creating a C program on the UNIX OS_:
  - The *text of a program* must be saved in a *file* whose name ends in ".c" (e.g., hello.c)
  - *Compile* this file with the command ~$ cc hello.c~ \rightarrow ~$ gcc hello.c~ on a GNU/Linux system
  - Compilation proceeds silently and makes an *executable file* named "*a.out*"
  - *Run* the latter by typing its name: ~$ a.out~ \rightarrow ~$ ./a.out~ on a GNU/Linux system

#+BEGIN_SRC C
  #include <stdio.h>

  main()
  {
          printf("hello, world\n");
  }
#+END_SRC

- _Explanations_:
  - A C program, whatever its size, consists of /functions/ and /variables/
    - *Functions* contain /statements/ that specify the computing operations to be done
      - The statements of a function are enclosed in braces ~{}~
    - *Variables* store values used during the computation

  - When defined, functions and variables can be given *any name* (except reserved keywords)
    - *Exception*: the program begins executing at the beginning of a function named ~main~ \rightarrow Every program must have a ~main~ function somewhere
      - ~main~ will usually *call other functions* that you either wrote or present in the standard library

  - ~#include <stdio.h>~ tell the *preprocessor* to include information about the *standard input/output library*

  - A function is called by *naming it*, followed by *a parenthesized list of arguments*
    - One method of *communicating data between functions* is for the *calling function* to provide *a list of values*, called /arguments/, to the *function it calls*
    - The argument list is delimited by a *pair of parentheses* after the function name \rightarrow Even if a function expects no arguments, an empty list ~()~ must be specified
    - (C functions are like the subroutines and functions of Fortran or the procedures and functions of Pascal)

  - A sequence of characters delimited by double quotes "" is called a /character string/ (or /string constant/)
    - The sequence ~\n~ is C notation for the /newline character/
      - ~\n~ is called an /escape sequence/ \rightarrow Provides a *general and extensible mechanism* for representing *hard-to-type or invisible characters*
	- ~\n~ represents *a single character* (at least on UNIX)
	- An *error message* might be produced by the C compiler when trying to *substitute an escape sequence* by the character it produces (e.g., the statement below)
      - If omitted, no line advance will occur after the output is printed \rightarrow ~printf~ never supplies a newline automatically and might be called *several times* to build up an output line in stages

#+BEGIN_SRC C
  printf("hello, world
  ");
#+END_SRC

_Exercises_:
- [[file:exercises/1-1/hello.c][Exercise 1-1]]
- [[file:exercises/1-2/escape_sequences.c][Exercise 1-2]]


** 1.2 Variables and Arithmetic Expressions

- A /comment/ explains briefly what the program does \rightarrow Make it easier to understand
  - Any characters between ~*/~ and ~*/~ are *removed by the preprocessor* before compilation
  - Comments may appear *anywhere a blank or tab or newline can*

- A /statement/ is terminated by a semicolon ~;~ \rightarrow Permits to *distinguish statements from what are not them*

- A /declaration/ announces the *properties of variables*
  - *All variables must be declared before they are used in C* \rightarrow Usually at the *beginning of the function* before any executable statement
  - declaration = type name + a list of variables \rightarrow E.g., ~int fahr, celsius;~
  - The size of the objects of these types are *machine-dependent* (e.g., 32-bit ~ints~ VS 16-bit ~ints~)
  - (Other data structures utilizes these basic types to create bigger data types)

- _Basic data types_ (non-exhaustive):

| Type     | Description                                                                            |
|----------+----------------------------------------------------------------------------------------|
| ~int~    | integer                                                                                |
| ~float~  | floating point number (typically a 32-bit quantity, with at least 6 significant digits) |
| ~char~   | character (a single byte quantity)                                                     |
| ~short~  | short integer                                                                          |
| ~long~   | long integer                                                                           |
| ~double~ | double-precision floating point                                                        |

- An /assignment statement/ assigns a value to a variable \rightarrow E.g., ~lower = 0;~
  - (This is where the computation starts in the provided program)

- A *loop* repeats one or more statements while *a condition is true*
  - Composed of: *a condition* enclosed in parentheses ~()~ + *a body* enclosed in braces ~{}~ (optional if it contains a single statement)
  - The condition is *retested at each iteration*
  - When the condition becomes false, the *execution continues* at the next statement

- *Proper indentation and spacing* are not required by the compiler but are *critical to make the program easier to read*
  - The /indentation/ emphasizes the *logical structure of a program*
    - E.g, statements inside the loop are indented by one tab stop
  - *One statement per line* is recommended
  - *Blanks placed around operators* clarify grouping
  - The *position of braces* is less important and depends on the style picked
    - \rightarrow *No matter what the style is, the important is to use it consistently*

- *Integer division truncates* in C (as in many other languages) \rightarrow *Any fractional part is discarded*
  - ~celsius = 5 * (fahr-32) / 9~ would *result in 0* if the division was the first operation \rightarrow *But the result is still truncated*
    - If an arithmetic operator has *integer operands*: *an integer operation* is performed
  - The ~float~ *type can be used instead*
    - If an arithmetic operand has *one integer and one floating-point operand*: *integer operand is converted to floating-point operand* and *floating-point operation* is performed
      - Prefer to write floating-point constants *ending with* ~.0~ (or ~.~) instead of integer constants when *dealing with other floating-point operands* \rightarrow Emphasizes their *floating-point nature* and *avoid conversion*

- ~printf~ is *a general-purpose output formatting function*
  - *Not part of the C language* (no i/o defined in C itself) but part of the *standard library*
  - The first argument is the *string of characters to be printed*
  - The other arguments are the *values that substitutes each format specifier*
    - ~%d~ and ~%f~ can be augmented with a *minimum width* (right-justifies) \rightarrow E.g., ~%3d~, ~%2f%~
    - ~%f~ can be be augmented with a *maximum number of digits after the decimal point* \rightarrow E.g., ~%.2f%, ~%3.0f%~
  - (Format specifiers and arguments must match up properly by *number* and *type* under penalty of wrong output)

- _Format specifiers_ (non-exhaustive):

| Format specifier | Specified argument |
|------------------+--------------------|
| ~%d~             | integer            |
| ~%f~             | floating-point     |
| ~%o~             | octal              |
| ~%x~             | hexadecimal        |
| ~%c~             | character          |
| ~%s~             | character string   |

- ~%%~ must be used to output the ~%~ itself

_Exercises_:
- [[file:exercises/1-3/f_to_c.c][Exercise 1-3]]
- [[file:exercises/1-4/c_to_f.c][Exercise 1-4]]


** 1.3 The For Statement

- *General rule*: In any context where it is permissible to use the value of a variable of some type. you can use *a more complicated expression of that type*

- There are *plenty of different ways* to write a program for *a particular task*

- A ~for~ loop can be used instead of the ~while~ in the previous program
  - Generalization of a ~while~
  - Appropriate for loops in which the *initialization* and *increment* are *single statements* and *logically related*
  - Keeps the loop control statements *together in one place*

- _For loop syntax_:

#+BEGIN_SRC C
  for (/* initialization */; /* condition */; /* increment */) {
          /* body */
  }
#+END_SRC

- Parts:
  - *Initialization*: assign a value to a variable when the loop is entered \rightarrow Not a variable declaration
  - *Condition*: specifies when the loop ends + re-evaluated at each iteration
  - *Increment*: update the value of a variable at each iteration
- Most of the time, these parts are related to *a same variable* \rightarrow Not mandatory though
- Thus, they can be *any expressions*
  - Any part can even be *empty* between the ~;~ \rightarrow Infinite loop if none

- *Recommendation for loops*: use a ~for~ *when the number of iterations is known beforehand* and a ~while~ *when not*

_Exercises_:
- [[file:exercises/1-5/f_to_c.c][Exercise 1-5]]


** 1.4 Symbolic Constants

- *Bad practice*: bury "magic numbers" in a program (e.g., 300, 20) \rightarrow Convey little information to the reader + Must change all occurrences when updating values
  - *Solution*: give them meaningful name via /symbolic constants/

- _Symbolic constant syntax_:

#+BEGIN_SRC C
  #define NAME replacement_text
#+END_SRC

- *A search and replace operation*: Any occurrence of ~NAME~ will be *replaced* by the corresponding ~replacement_text~ in the program text \rightarrow Done during the *preprocessing step*
  - ~NAME~ will not be replaced when *in quotes* or *part of another name*
  - ~NAME~ must respect the naming rules as *a variable name* \rightarrow Conventionally written in *upper case* to be readily distinguished
  - ~replacement_text~ can be *any text* that will *make sense when replaced with* (e.g., integers, floating-point number, type, type with variable name, function name, text in quotes)

- Symbolic constants must *not appear in declarations* since they are not variables \rightarrow Generally under ~#include~ directives
- (Note that there is no ~;~)


** 1.5 Character Input and Output

- Chapter focuses on *a family of related programs* for *processing character data*
  - Many UNIX programs are just *expanded versions* of the prototypes discussed

- The *model of input and output* supported by the *standard library* is very simple: text input or output is dealt with as *stream of characters*
  - A /text stream/ is a *sequence of characters* divided into *lines*; each line consists of *zero or more characters* followed by *a newline character*
  - The *standard library* is responsible for making each input or output stream *conform to this model* \rightarrow Thus, programmer does not need to worry about *how lines are represented outside the program*

- Several functions are provided for *reading or writing one character at a time*
  - *Simplest ones*:
    - ~getchar~: reads the /next input character/ from a text stream and returns that as its value (e.g., ~c = getchar()~)
    - ~putchar~: prints the character passed as argument (e.g. ~putchar('A')~ \rightarrow ~A~, ~putchar(97)~ \rightarrow ~a~)


*** 1.5.1 File Copying

- ~getchar~ and ~putchar~ are *sufficient to write useful programs* without knowing anything more about *input and output*

#+BEGIN_SRC C
  #include <stdio.h>

  /* copy input to output */
  main()
  {
          int c;

          while ((c = getchar()) != EOF)
                  putchar(c);
  }
#+END_SRC

- A character is *stored internally as a bit pattern* \rightarrow Like everything else on a computer
- The ~c~ variable is used to *store and reuse the read character* \rightarrow If you do not need to work on the read character (e.g., with a counter), you *do not need a variable*
- Although the data type ~char~ is specifically meant for storing characters, ~int~ is used instead because it provides *a wider range of values* to hold characters not present in the ASCII table
  - (+ Apparently, there was a time where ~char~ could not hold ~EOF~ + any possible ~char~)

- ~EOF~ ("*End of file*") is a *symbolic constant* defined in ~<stdio.h>~ that can be used to *distinguish the end of input from valid data*
  - Has to be *distinct from any character that can be found in a file* to serve its purpose \rightarrow Often defined as -1
  - The ~EOF~ value is returned by ~getchar~ when there is *no more input*

- *Expressions* in C have *a value*
  - *Assignments* are expressions and their value is the *one of the left hand side* after the assignment
    - Thus, assignments can be part of *another expression* (e.g., ~(a = 8) + 8~) \rightarrow Easier to read once the *idiom is mastered*
      - ~()~ *are necessary* \rightarrow The /precedence/ of ~!=~ is *higher than that of* ~=~

_Exercises_:
- [[file:exercises/1-6/i2bool.c][Exercise 1-6]]
- [[file:exercises/1-7/eofval.c][Exercise 1-7]]


*** 1.5.2 Character Counting

#+BEGIN_SRC C
  #include <stdio.h>

  /* count characters in input */
  main()
  {
          long nc;                /* number of characters */

          nc = 0;
          while (getchar() != EOF)
                  ++nc;
          printf("%ld\n", nc);
  }
#+END_SRC

- The ~++~ operator /increments by one/ the value of a variable \rightarrow Shorter than ~nc  = nc + 1~
  - The ~--~ operator exists just as well (/decrements/)
  - They can be either *prefix operators* (e.g., ~++nc~) or *postfix* (e.g., *nc++*) \rightarrow Stick to the *prefix form* most of the time

- The ~long~ type (at least 32-bit) is used because the number of characters in a file can easily *overflow a ~16-bit int~ counter*
  - Although, the ~long~ and ~int~ types are the *same size on modern computers* most of the time
  - ~%ld~ is the *format specifier for* a ~long~ integer
  - An even *wider range of values* could have been provided *utilizing a ~double~ counter*

#+BEGIN_SRC C
  double nc;

  for (nc = 0; getchar() != EOF; ++nc)
          ;
  printf("%.0f\n", nc);
#+END_SRC

- If a *single operation* is executed while iterating through the file, one could prefer using *a ~for~ statement*
  - The grammatical rules of C *require that a ~for~ statement have a body* \rightarrow Represented by the ~;~, called a /null statement/ (newline for visibility, not mandatory + Empty ~{}~ could have been used as well)
  - The *increment part* of the for loop could have been omitted and *placed in the loop body* \rightarrow Clearer to use a ~while~ in that case (+ if there is more than one statement while iterating through)

- Since a ~double~ is a floating-point value, ~%.0~ must be used to *truncate its fractional part*

- *Important*: For both ~while~ and ~for~ versions, the *boundary case* "zero length input" prints the right answer
  - \rightarrow The *loop condition is evaluated at the top of the loop* for both, before proceeding with the body
  - ~getchar~ returns ~EOF~ at the very first test \rightarrow The condition is *false* \rightarrow The body of the loop is *never entered*

- \rightarrow *Programs should act intelligently when tested with boundary conditions*


*** 1.5.3 Line Counting

#+BEGIN_SRC C
  #include <stdio.h>

  /* count lines in input */
  main()
  {
          int c, nl;

          nl = 0;
          while ((c = getchar()) != EOF)
                  if (c == '\n')
                          ++nl;
          printf("%d\n", nl);
  }
#+END_SRC

- Since the standard library ensures that text streams follows the same model, *counting lines is just counting newlines*

- ~==~ is the C notation for "*is equal to*" \rightarrow Different from the *assignment operator ~=~* \rightarrow *Warning: both operators produces legal expressions*

- A /character constant/ is *a character written between single quotes* that represents *an integer value equal to the numerical value of the character in the machine's character set* (e.g., ~'A' == 65~ is true)
  - An escape sequence is interpreted as *a single character* \rightarrow Thus, they are legal as *character constants* (e.g., ~'\n' == 10~ is true)
    - *Different from the string constant ~"\n"~* (which contains one character: ~'\n'~)

#+BEGIN_SRC C
  char c;

  for (c = 'A'; c <= 'Z'; ++c) {
          /* iterates over characters A to Z */
  }
#+END_SRC

- \righarrow *Always prefer to work with character constants over their numerical value*
  - + Independence of *a particular character set* (even if ASCII is almost always used)

_Exercises_:
- [[file:exercises/1-8/spcc.c][Exercise 1-8]]
- [[file:exercises/1-9/sb.c][Exercise 1-9]]
- [[file:exercises/1-10/spcr.c][Exercise 1-10]]
