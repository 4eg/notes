#+TITLE: The C Programming Language - Notes

The C Programming Language
Second edition
1988
Brian W. Kernighan
Denis M. Ritchie


* Preface

- *1978*: release of the *first edition* of /The C Programming Language/
  - The *only definition* for the C language at the time
  - Growing popularity + Changes + Creation of compilers by groups not involved in its design = Need for a more precise and contemporary definition

- *1983*: the ANSI established a committee whose goal was to create "an an unambiguous and machine-independent definition of the language C"
  - Based on the original reference manual
  - *Minor changes only* to ensure *compatibility* with existing programs \rightarrow Compilers would produce warnings of new behavior if not valid
  - \rightarrow The resulting definition, the *ANSI standard* or "*ANSI C*", was completed late in 1988

- *1988*: release of the *second edition* of /The C Programming Language/
  - Describes C as defined by the *ANSI standard*
  - Programs are written *exclusively* in the new form (no changes for the most part) + Improved examples with better exposition of features
  - Modern compilers *already complies* with the ANSI standard at the time
  - Brevity: "*C is not a big language, and it is not well served by a big book*"
  - Meant for *easy comprehension by programmers*, but *not as a definition for compiler writers* \rightarrow That role belongs to the standard itself
  - (Growth of the computing power: of PCs is the same of the rival mainframes of a decade ago)
  - (The authors were provided with an ANSI C compiler and used Bjarne Stroustrup's C++ translator)

- \rightarrow C "*wears well as one's experience with it grows*" is still true after a decade



* Preface to the First Edition

- C is a *general-purpose* programming language
  - Features: *economy of expression*, *modern control flow and data structures*, and a *rich set of operators*
  - Not a "very high level language", nor a "big" one, and versatile (i.e., not specialized to any particular area of application)
  - A "*system programming language*" as well: useful for writing compilers and operating system \rightarrow "*C is a portable assembly language*"
  - Absence of restrictions + Generality = More convenient and effective than supposedly more powerful languages

- C was originally designed for and implemented on the UNIX OS
  - The *OS*, the *C compiler*, and all *UNIX applications programs* are written in C \rightarrow *Thus, UNIX became the first portable operating system*
  - Portable: C is *not tied to any particular hardware or system* (the targeted architecture requires an implementation of the compiler, though)
  - (Created on the DEC PDP-11 by Dennis Ritchie)

- This book is based on *revising examples* rather than on *mere statements of rules*
  - Most of the examples are *concrete programs* rather than *isolated fragments of code* \rightarrow Illustrate useful algorithms and principle of good style and sound design
  - *Content*: Tutorial introduction + Separate chapters for each major feature + Reference manual
  - Assumes that the reader is familiar with basic programming concepts
  - (Each example has been tested directly from text, which is in a machine-readable form)

- \rightarrow "The *only way* to learn a new programmming language is by *writting programs in it*."



* Introduction

- C is a relatively *low level* language \rightarrow Deals with the same sort of *objects that most computers do* (i.e., characters, numbers and addresses)
  - They may be *combined* and *moved about* with the arithmetic and logical operators implemented by real machines

- _C does feature_:

  - In addition to *fundamental types* (i.e., characters, integers and floating-point numbers of several sizes), there is a hierarchy of *derived data types* created with pointers, arrays and unions
  - *Expressions* are formed from operators and operands; any expression, including an assignment or a function call, can be a statement
  - *Pointers* provide for machine-independent address arithmetic

  - *Control-flow constructions*:
    - Statement grouping
    - Decision making (~if-else~)
    - Selecting one of a set of possible cases (~switch~)
    - Looping with the termination test at the top (~while~, ~for~) or at the bottom (~do~)
    - Early loop exit (~break~)

  - *Functions* may return values of basic types, structures, unions, or pointers
    - Any function may be called *recursively*
    - *Local variables* are typically "automatic", or created anew with each invocation
    - Functions may not be *nested*, but variables may be declared in a block-structured fashion
    - They may exist in a *separate* source files that are compiled separately

  - *Variables* may be:
    - *Internal* to a function
    - *External* but known only within a single source file
    - *Visible to the entire program*

  - A *preprocessing step* performs:
    - *Macro substitution* on program text
    - *Inclusion* of other source files
    - *Conditional compilation*

  - *Straightforward* and *single-thread* control flow: tests, loops, grouping, and subprograms, but not multiprogramming, parallel operations, synchronization, or coroutines

- _C does not feature_:

  - *Operations* to deal directly with *composite objects* such as character string, sets, lists, or array \rightarrow Although structures may be copied as a unit
  - *Heap* or *garbage collection*: no *storage allocation facility* other than *static definition* and the *stack discipline* provided by the local variables of functions
  - *Input/output facilities* (i.e., no READ or WRITE statements) nor built-in *file access methods*

- All of these higher-level mechanisms must be provided by *explicitly-called functions*
  - Although the absence of some of these features may seem like a *grave deficiency*, keeping the language down to *modest size has real benefits*
    - It can be described in a *small space*, and thus *learned quickly* \rightarrow A programmer can reasonably expect to *know*, *understand*, and *regularly use* the *entire language*

- Many of the important ideas of C stem from the *language BCPL*
  - The influence of BCPL on C proceeded indirectly through the language B
  - In contrast to C, B and BCPL are *typeless* languages
  - (1970: creation of the language B by Ken Thompson on the DEC PDP-7)

- _Contributions brought by the standard to the language_:

  - _Language changes_:
    - Most important one: *new syntax for declaring and defining functions*
      - Permits *cross-checking of definition with use*
      - A function declaration can now include a *description of the arguments* of the function; the definition syntax changes to match
      - \rightarrow Much easier for compiler to detect errors caused by mismatched arguments
    - Other ones:
      - Formalization of *structure assignment* and *enumerations* \rightarrow They were hinted bu not described in the original definition
      - *Floating-point computations* may now be done in *single precision*
      - *Properties of arithmetic* are clarified \rightarrow Especially for unsigned types
      - The *preprocessor* is more elaborate
      - *Type-checking* has been strengthened (e.g., interchange of pointers and integers are now forbidden)
	- *Proper declarations* and *explicit conversions* are now required by the standard (but was already enforced in good compilers)
	- New function declarations are a step in this direction as well

  - _Definition of a library to accompany C_ \rightarrow Provides a common interface to the OS
    - *A collection of standard headers* provides uniform access to *declarations of function* and *data types*
    - *Assurance of compatible behavior* when a program using it is executed on different host systems
    - Closely modeled on the *standard I/O library* of the UNIX system (described in the first edition) \rightarrow Programmers will not see much change with the new library
    - Specifies *functions* for:
      - Accessing the OS* (e.g., read and write files)
      - Formatted input and output
      - Memory allocation
      - String manipulation
      - ...
    - Functions are only called *explicitly* \rightarrow The library can be avoided if not used
    - Most of these functions are *written in C* \rightarrow Thus they are *portable* (except for the OS details they might conceal)

- The *run-time library* required to implement self-contained program is *tiny* \rightarrow Due to direct support of data types and control structures provided

- *Portability*: C is independent of any particular *machine architecture* despite it matches the capabilities of many computers
  - The standard states explicitly *machine-dependent aspects* of the language \rightarrow Description of *portability issues* and *a set of constant that characterizes the host machine*

- C is not a *strongly-typed* language
  - Compilers will warn of most *type errors*, and there is *no automatic conversion* of incompatible data types
  - C retains the basic philosophy that "*programmers know what they are doing; it only requires that they state their intentions explicitly*"

- *Blemishes*:
  - Some of the operators have the *wrong precedence*
  - Some parts of the syntax *could be better* ([[https://stackoverflow.com/a/46759840][proof]])

- \rightarrow Nonetheless, C has proven to be an extremely *effective* and *expressive* language for a wide variety of programming applications



* Chapter 1: A Tutorial Introduction

- Shows the *essential elements* of the language without getting bogged down in details, rules and exceptions
- Neither complete or precise \rightarrow Features to write bigger programs are put aside (e.g, pointers, structures, set of operators, several control flow statements, standard library)
- *Focus on the basics*: variables and constants, arithmetic, control flow, functions, and the rudiments of input and output \rightarrow Write useful programs ASAP
- Can be used as a *framework* for programmers of any level

- Drawbacks of this approach:
  - *No complete story* on any particular feature
  - May be *misleading*
  - Not using the *full power of C* \rightarrow Programs are not as *elegant* and concise as they might be
  - Later chapters will necessarily repeat some of the contents of this one


** 1-1 Getting Started

- _Creating a C program on the UNIX OS_:
  - The *text of a program* must be saved in a *file* whose name ends in ".c" (e.g., hello.c)
  - *Compile* this file with the command ~$ cc hello.c~ \rightarrow ~$ gcc hello.c~ on a GNU/Linux system
  - Compilation proceeds silently and makes an *executable file* named "*a.out*"
  - *Run* the latter by typing its name: ~$ a.out~ \rightarrow ~$ ./a.out~ on a GNU/Linux system

#+BEGIN_SRC C
  #include <stdio.h>

  main()
  {
          printf("hello, world\n");
  }
#+END_SRC

- _Explanations_:
  - A C program, whatever its size, consists of /functions/ and /variables/
    - *Functions* contain /statements/ that specify the computing operations to be done
      - The statements of a function are enclosed in braces ~{}~
    - *Variables* store values used during the computation

  - When defined, functions and variables can be given *any name* (except reserved keywords)
    - *Exception*: the program begins executing at the beginning of a function named ~main~ \rightarrow Every program must have a ~main~ function somewhere
      - ~main~ will usually *call other functions* that you either wrote or present in the standard library

  - ~#include <stdio.h>~ tell the *preprocessor* to include information about the *standard input/output library*

  - A function is called by *naming it*, followed by *a parenthesized list of arguments*
    - One method of *communicating data between functions* is for the *calling function* to provide *a list of values*, called /arguments/, to the *function it calls*
    - The argument list is delimited by a *pair of parentheses* after the function name \rightarrow Even if a function expects no arguments, an empty list ~()~ must be specified
    - (C functions are like the subroutines and functions of Fortran or the procedures and functions of Pascal)

  - A sequence of characters delimited by double quotes "" is called a /character string/ (or /string constant/)
    - The sequence ~\n~ is C notation for the /newline character/
      - ~\n~ is called an /escape sequence/ \rightarrow Provides a *general and extensible mechanism* for representing *hard-to-type or invisible characters*
	- ~\n~ represents *a single character* (at least on UNIX)
	- An *error message* might be produced by the C compiler when trying to *substitute an escape sequence* by the character it produces (e.g., the statement below)
      - If omitted, no line advance will occur after the output is printed \rightarrow ~printf~ never supplies a newline automatically and might be called *several times* to build up an output line in stages

#+BEGIN_SRC C
  printf("hello, world
  ");
#+END_SRC

_Exercises_:
- [[file:exercises/1-1/hello.c][Exercise 1-1]]
- [[file:exercises/1-2/escape_sequences.c][Exercise 1-2]]


** 1.2 Variables and Arithmetic Expressions

- A /comment/ explains briefly what the program does \rightarrow Make it easier to understand
  - Any characters between ~*/~ and ~*/~ are *removed by the preprocessor* before compilation
  - Comments may appear *anywhere a blank or tab or newline can*

- A /statement/ is terminated by a semicolon ~;~ \rightarrow Permits to *distinguish statements from what are not them*

- A /declaration/ announces the *properties of variables*
  - *All variables must be declared before they are used in C* \rightarrow Usually at the *beginning of the function* before any executable statement
  - declaration = type name + a list of variables \rightarrow E.g., ~int fahr, celsius;~
  - The size of the objects of these types are *machine-dependent* (e.g., 32-bit ~ints~ VS 16-bit ~ints~)
  - (Other data structures utilizes these basic types to create bigger data types)

- _Basic data types_ (non-exhaustive):

| Type     | Description                                                                            |
|----------+----------------------------------------------------------------------------------------|
| ~int~    | integer                                                                                |
| ~float~  | floating point number (typically a 32-bit quantity, with at least 6 significant digits) |
| ~char~   | character (a single byte quantity)                                                     |
| ~short~  | short integer                                                                          |
| ~long~   | long integer                                                                           |
| ~double~ | double-precision floating point                                                        |

- An /assignment statement/ assigns a value to a variable \rightarrow E.g., ~lower = 0;~
  - (This is where the computation starts in the provided program)

- A *loop* repeats one or more statements while *a condition is true*
  - Composed of: *a condition* enclosed in parentheses ~()~ + *a body* enclosed in braces ~{}~ (optional if it contains a single statement)
  - The condition is *retested at each iteration*
  - When the condition becomes false, the *execution continues* at the next statement

- *Proper indentation and spacing* are not required by the compiler but are *critical to make the program easier to read*
  - The /indentation/ emphasizes the *logical structure of a program*
    - E.g, statements inside the loop are indented by one tab stop
  - *One statement per line* is recommended
  - *Blanks placed around operators* clarify grouping
  - The *position of braces* is less important and depends on the style picked
    - \rightarrow *No matter what the style is, the important is to use it consistently*

- *Integer division truncates* in C (as in many other languages) \rightarrow *Any fractional part is discarded*
  - ~celsius = 5 * (fahr-32) / 9~ would *result in 0* if the division was the first operation \rightarrow *But the result is still truncated*
    - If an arithmetic operator has *integer operands*: *an integer operation* is performed
  - The ~float~ *type can be used instead*
    - If an arithmetic operand has *one integer and one floating-point operand*: *integer operand is converted to floating-point operand* and *floating-point operation* is performed
      - Prefer to write floating-point constants *ending with* ~.0~ (or ~.~) instead of integer constants when *dealing with other floating-point operands* \rightarrow Emphasizes their *floating-point nature* and *avoid conversion*

- ~printf~ is *a general-purpose output formatting function*
  - *Not part of the C language* (no i/o defined in C itself) but part of the *standard library*
  - The first argument is the *string of characters to be printed*
  - The other arguments are the *values that substitutes each format specifier*
    - ~%d~ and ~%f~ can be augmented with a *minimum width* (right-justifies) \rightarrow E.g., ~%3d~, ~%2f%~
    - ~%f~ can be be augmented with a *maximum number of digits after the decimal point* \rightarrow E.g., ~%.2f%, ~%3.0f%~
  - (Format specifiers and arguments must match up properly by *number* and *type* under penalty of wrong output)

- _Format specifiers_ (non-exhaustive):

| Format specifier | Specified argument |
|------------------+--------------------|
| ~%d~             | integer            |
| ~%f~             | floating-point     |
| ~%o~             | octal              |
| ~%x~             | hexadecimal        |
| ~%c~             | character          |
| ~%s~             | character string   |

- ~%%~ must be used to output the ~%~ itself

_Exercises_:
- [[file:exercises/1-3/f_to_c.c][Exercise 1-3]]
- [[file:exercises/1-4/c_to_f.c][Exercise 1-4]]


** 1.3 The For Statement

- *General rule*: In any context where it is permissible to use the value of a variable of some type. you can use *a more complicated expression of that type*

- There are *plenty of different ways* to write a program for *a particular task*

- A ~for~ loop can be used instead of the ~while~ in the previous program
  - Generalization of a ~while~
  - Appropriate for loops in which the *initialization* and *increment* are *single statements* and *logically related*
  - Keeps the loop control statements *together in one place*

- _For loop syntax_:

#+BEGIN_SRC C
  for (/* initialization */; /* condition */; /* increment */) {
          /* body */
  }
#+END_SRC

- Parts:
  - *Initialization*: assign a value to a variable when the loop is entered \rightarrow Not a variable declaration
  - *Condition*: specifies when the loop ends + re-evaluated at each iteration
  - *Increment*: update the value of a variable at each iteration
- Most of the time, these parts are related to *a same variable* \rightarrow Not mandatory though
- Thus, they can be *any expressions*
  - Any part can even be *empty* between the ~;~ \rightarrow Infinite loop if none

- *Recommandation for loops*: use a ~for~ *when the number of iterations is known beforehand* and a ~while~ *when not*

_Exercises_:
- [[file:exercises/1-5/f_to_c.c][Exercise 1-5]]
